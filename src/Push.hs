{-# LANGUAGE OverloadedStrings #-}
module Push where

import Control.Applicative
import Network.Wreq
import Data.Aeson
import Data.Aeson.Lens
import Control.Lens hiding ((.=))
import Control.Monad.Reader
import qualified Data.ByteString.Lazy as BS
import qualified Data.ByteString.Char8 as BSC
import qualified Data.Text as T
import qualified Data.Text.IO as TIO
import Database.SQLite.Simple
import Turtle
import Shared

data Config = Config { _issueUser :: T.Text
                     , _issuePswd :: T.Text
                     , _user      :: T.Text
                     , _repo      :: T.Text
                     } deriving (Show, Eq)

type ConfigM = ReaderT (Connection, Config) IO

baseUrl :: String
baseUrl = "https://api.github.com/repos/"

cfgPath :: IsString a => a
cfgPath = ".git/hooks/gitdo.json"

body :: Config -> Todo -> T.Text
body cfg (Todo fp ln _ _)= "Autogenerated from [comment](https://github.com/"
                           <> _user cfg <> "/" <> _repo cfg <> "/blob/master/"
                           <> fromRight (toText fp) <> "#" <> T.pack (show ln)
                           <> ")"

createIssue :: Todo -> ConfigM ()
createIssue t@(Todo fp ln td _) = do
  (conn, cfg) <- ask
  let opts = defaults & auth ?~ basicAuth (BSC.pack $ T.unpack $ _issueUser cfg)
                                          (BSC.pack $ T.unpack $ _issuePswd cfg)
  let json = object ["title" .= td, "body" .= body cfg t]
  r <- liftIO $ postWith opts (baseUrl
                                <> T.unpack (_user cfg) <> "/"
                                <> T.unpack (_repo cfg) <> "/issues")
                              json
  liftIO $ print (r ^. responseBody)
  liftIO (execute conn
            "UPDATE todos SET status=? WHERE file=? AND line=? AND todo=?;"
            ("synced" :: T.Text, fp, ln, td))

updateIssue :: Todo -> ConfigM ()
updateIssue = undefined

createOrUpdate :: Todo -> ConfigM ()
createOrUpdate t@(Todo _ _ _ s)
  | s == "new" = createIssue t
  | s == "updated" = updateIssue t

parseConfig :: Maybe Value -> Maybe Config
parseConfig cfg =
  Config <$> (cfg ^. key "issue_creator" . key "user" . asText)
         <*> (cfg ^. key "issue_creator" . key "password" . asText)
         <*> (cfg ^. key "repo" . key "user" . asText)
         <*> (cfg ^. key "repo" . key "repo" . asText)

push :: IO ()
push = do
  cfgTxt <- BS.readFile cfgPath
  case decode cfgTxt >>= parseConfig of
    Just cfg -> do
      conn <- open dbPath
      todos <- query conn "SELECT * FROM todos" ()
      flip runReaderT (conn, cfg) $ mapM_ createOrUpdate todos
    Nothing -> die ("Make sure " <> cfgPath
                    <> " is valid json and has the required fields")
